Несколько долбанутых случаев, в которых javac плохо себя ведёт.

## Сломанный сабтайпинг(KT-7296)
```java
class Inv<T> {}
class A<T> {}
class B<T> extends A<A<T>> {}
```

java считает, что `Inv<B<?>>` подтип `Inv<? extends A<A<?>>>` но это не типобезопасно.
Пример с CC: https://youtrack.jetbrains.com/issue/KT-7296#comment=27-1413390

>  При этом B<?> не подтип A<A<?>>

Почему так происходит. Дело в том, что на топ-левеле мы можем captured типы создавать, а вот на 2-м уровне и выше -- нет.
Из-за этого в случае `B<?> <:? A<A<?>>` мы создаём `exist Q.B<Q> <:? A<A<?>>`. Далее это превращается в `A<A<Q>> <:? A<A<?>>` 
и обламывается, т.к. `A<?> != A<Q>`.

В случае `Inv<B<?>> <:? Inv<? extends A<A<?>>>` мы делаем иначе -- из-за `? extends` мы должны проверить, что
`B<?>` подтим `A<A<?>>`. При этом, мы не на топ-левеле, поэтому java считает, что тут нельзя применять capture conventions.
И она радостно считает, что у `B<?>` подставленный супертип есть `A<A<?>`. Естественно что после этого `A<A<?>>` оказывается
подтипом `A<A<?>>`. Тада.

**Починить это можно так**: сказать, что при проверки сабтайпинга можно всегда применять capture, 
даже в каких-то, казалось бы, не связанных с этим случаях. Аля `Inv<in Number> <:? Inv<out Comparable<*>>`.
Да, capture надо делать только с левой частью выражения и только на топ-левеле.

**Подумать**: как это уживается с упрощением констрейнтов в констрейн системе?

## Звёздочка и котлин (KT-11979)

https://jetbrains.slack.com/archives/kotlin-design/p1460667989000618

```kotlin
class Bar<T>(val t: T)
class Foo<F : Bar<F>>(val f: F)

val f: Foo<*> = TODO()
```

Если мы возьмём тип у выражения `f.f`, то он сейчас будет `Bar<*>`, но при этом там `*` имеет весьма специальную
странную природу. Дело в том, что если мы посмотрим тип у `f.f.t`, то он тоже будет `Bar<*>`. Это значит, что звёздочка
"помнит" про то, какой у нее супертип. Но при этом сабтайпинг это продалбывает и считает, что у него обычный такой тип
`Bar<*>`.

Собственно можно получить CC. Пример тут: https://youtrack.jetbrains.com/issue/KT-11979

**Починка:**
`Foo<*>` значит следующее: `Foo<[]>`, где когда у `[]` мы спросим, что же это за проэкция, он нам скажет `out Bar<[]>`, где если мы опять спросим, что  же там за `[]` нам ответят `out Bar<[]>` и т.д. На самом деле, всё примерно так сейчас и происходит, но из-за того, что в компиляторе звёздочка параметризованная(у неё есть неявный супертип) то не корректно считать, что `Bar<A>` подтип `Bar<*>` для любого `A`.
