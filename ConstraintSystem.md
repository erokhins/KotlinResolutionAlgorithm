```kotlin
fun <X> bar(x: X?, y: X): X = TODO()

class Foo<T: S, S> {
    
    fun test(t: T, s: S) {
        val bar = bar(t, s)
    }
}
```
Тут всё плохо. Дело в том, что:
```
T? <: V <=> T <: V && Nothing? <: V
T? >: V <=> V & Any <: T
```
откуда в примере выше получаем, что:
```
T <: X? && S <: X <=> T & Any <: X && S <: X
```
После этого надо как-то решить эту *** систему :(
А именно, придумать алгоритм, по которому lsb(`T & Any`, `S`) = S


## Intersection on left hand

Обсудим пример: `T & List<S> <: List<Int>`. Хорошо бы в этот момент выводить, что `S <: Int`. Сейчас мы тупо выводим, что `T <: List<Int>`, а в более плохом случае `T & S <: Int` мы говорим, что `T <: Int && S <: Int`. Как это правильно чинить -- не понятно. Пока так. Естественно, из-за этого про некоторые системы мы будем говорить, что они противоречивые. Но вот не понятно, плохо ли это. В общем, подождём времён, когда intersection типы будут полностью в языке.


Ещё проблема с incorporation-ом: дело в том, что contains не отвечает верно про тип `A & B` есть ли там `A`. Он говорит, что нет. Из-за этого, некоторые constrain-ты не будут проинкорпорированы. Аналогично есть проблемы с capturedTypeApproximation-сом.
