Несколько долбанутых случаев, в которых javac плохо себя ведёт.

## Сломанный сабтайпинг:
```java
class Inv<T> {}
class A<T> {}
class B<T> extends A<A<T>> {}
```

java считает, что `Inv<B<?>>` подтип `Inv<? extends A<A<?>>>` но это не типобезопасно.
Пример с CC: https://youtrack.jetbrains.com/issue/KT-7296#comment=27-1413390

>  При этом B<?> не подтип A<A<?>>

Почему так происходит. Дело в том, что на топ-левеле мы можем captured типы создавать, а вот на 2-м уровне и выше -- нет.
Из-за этого в случае `B<?> <:? A<A<?>>` мы создаём `exist Q.B<Q> <:? A<A<?>>`. Далее это превращается в `A<A<Q>> <:? A<A<?>>` 
и обламывается, т.к. `A<?> != A<Q>`.

В случае `Inv<B<?>> <:? Inv<? extends A<A<?>>>` мы делаем иначе -- из-за `? extends` мы должны проверить, что
`B<?>` подтим `A<A<?>>`. При этом, мы не на топ-левеле, поэтому java считает, что тут нельзя применять capture conventions.
И она радостно считает, что у `B<?>` подставленный супертип есть `A<A<?>`. Естественно что после этого `A<A<?>>` оказывается
подтипом `A<A<?>>`. Тада.

**Починить это можно так**: сказать, что при проверки сабтайпинга можно всегда применять capture, 
даже в каких-то, казалось бы, не связанных с этим случаях. Аля `Inv<in Number> <:? Inv<out Comparable<*>>`.
Да, capture надо делать только с левой частью выражения и только на топ-левеле.

**Подумать**: как это уживается с упрощением констрейнтов в констрейн системе?

